<a id = "jump">[首页](/README.md)</a>
<!-- TOC -->

- [class.forName()和classLoader.loadClass()区别](#classforname和classloaderloadclass区别)
- [数据库链接为什么使用Class.forName(className)](#数据库链接为什么使用classfornameclassname)
- [类加载过程](#类加载过程)
    - [加载：（重点）](#加载重点)
    - [验证：（了解）](#验证了解)
    - [准备：（了解）](#准备了解)
    - [解析：（了解）](#解析了解)
- [类加载器](#类加载器)
    - [类与类加载器](#类与类加载器)
    - [双亲委派模型](#双亲委派模型)
- [java内存区域](#java内存区域)
- [堆，栈，方法区存储内容](#堆栈方法区存储内容)
- [垃圾回收](#垃圾回收)
    - [如何确定某个对象是“垃圾”](#如何确定某个对象是垃圾)
    - [典型的垃圾收集算法](#典型的垃圾收集算法)
- [常用JVM优化参数](#常用jvm优化参数)
- [JAVA 内存模型](#java-内存模型)
- [内存溢出和内存泄漏](#内存溢出和内存泄漏)
    - [内存泄露的几种场景](#内存泄露的几种场景)
    - [避免内存泄漏](#避免内存泄漏)
    - [内存溢出](#内存溢出)
        - [堆内存溢出](#堆内存溢出)
        - [方法区内存溢出](#方法区内存溢出)
        - [线程栈溢出](#线程栈溢出)
- [垃圾收集器](#垃圾收集器)
    - [G1](#g1)
        - [基础知识](#基础知识)
        - [G1的重要概念](#g1的重要概念)
        - [G1的过程](#g1的过程)
        - [两个模式](#两个模式)
        - [巨型对象的管理](#巨型对象的管理)
        - [G1执行过程中的异常情况](#g1执行过程中的异常情况)
        - [G1的调优](#g1的调优)
        - [G1的最佳实践](#g1的最佳实践)
        - [常见问题](#常见问题)
    - [CMS](#cms)
        - [基础知识](#基础知识)
        - [CMS的过程](#cms的过程)
        - [CMS的异常情况](#cms的异常情况)
        - [CMS的调优](#cms的调优)
        - [CMS优劣点](#cms优劣点)
        - [问题](#问题)
<!-- /TOC -->

# class.forName()和classLoader.loadClass()区别
Class.forName(className)方法，内部实际调用的方法是  Class.forName(className,true,classloader);第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。一旦初始化，就会触发目标对象的 static块代码执行，static参数也也会被再次初始化。  
ClassLoader.loadClass(className)方法，内部实际调用的方法是  ClassLoader.loadClass(className,false);不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行.
class.forName()除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。  
Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象  

[toTop](#jump)

# 数据库链接为什么使用Class.forName(className)
JDBC  Driver源码如下,因此使用Class.forName(classname)才能在反射回去类的时候执行static块。

```java
static {
    try {
        java.sql.DriverManager.registerDriver(new Driver());
    } catch (SQLException E) {
        throw new RuntimeException("Can't register driver!");
    }
}
```

[toTop](#jump)

# 类加载过程
![](/img/class_loader_process.jpg)
## 加载：（重点）
加载阶段是“类加载机制”中的一个阶段，这个阶段通常也被称作“装载”，主要完成：
1.通过“类全名”来获取定义此类的二进制字节流
2.将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3.在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口   
相对于类加载过程的其他阶段，加载阶段(准备地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段可以使用系统提供的类加载器(ClassLoader)来完成，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。   
加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式有虚拟机实现自行定义，虚拟机并未规定此区域的具体数据结构。然后在java堆中实例化一个java.lang.Class类的对象，这个对象作为程序访问方法区中的这些类型数据的外部接口。   
## 验证：（了解）
验证是链接阶段的第一步，这一步主要的目的是确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。
验证阶段主要包括四个检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。  
## 准备：（了解）
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的知识点，首先是这时候进行内存分配的仅包括类变量(static 修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为:

```java
public static int value  = 12;
```

那么变量value在准备阶段过后的初始值为0而不是12，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器\<clinit>()方法之中，所以把value赋值为12的动作将在初始化阶段才会被执行。

上面所说的“通常情况”下初始值是零值，那相对于一些特殊的情况，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，建设上面类变量value定义为：

```java
public static final int value = 123;
```

编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value设置为123。
## 解析：（了解）
解析阶段是虚拟机常量池内的符号引用替换为直接引用的过程。
符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。

直接引用：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。
* 类、接口的解析
* 字段解析
* 类方法解析
* 接口方法解析
5.初始化：（了解）

类的初始化阶段是类加载过程的最后一步，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器\<clinit>()方法的过程。在以下四种情况下初始化过程会被触发执行：
1.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。生成这4条指令的最常见的java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候，以及调用类的静态方法的时候。
2.使用java.lang.reflect包的方法对类进行反射调用的时候
3.当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化
4.jvm启动时，用户指定一个执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类
在上面准备阶段 

```java
public static int value  = 12; 
```

 在准备阶段完成后 value的值为0，而在初始化阶调用了类构造器\<clinit>()方法，这个阶段完成后value的值为12。
* 类构造器\<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句快可以赋值，但是不能访问。
* 类构造器\<clinit>()方法与类的构造函数(实例构造函数\<init>()方法)不同，它不需要显式调用父类构造，虚拟机会保证在子类\<clinit>()方法执行之前，父类的\<clinit>()方法已经执行完毕。因此在虚拟机中的第一个执行的\<clinit>()方法的类肯定是java.lang.Object。
* 由于父类的\<clinit>()方法先执行，也就意味着父类中定义的静态语句快要优先于子类的变量赋值操作。
* \<clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句，也没有变量赋值的操作，那么编译器可以不为这个类生成\<clinit>()方法。
* 接口中不能使用静态语句块，但接口与类不太能够的是，执行接口的\<clinit>()方法不需要先执行父接口的\<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的\<clinit>()方法。
* 虚拟机会保证一个类的\<clinit>()方法在多线程环境中被正确加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程执行这个类的\<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行\<clinit>()方法完毕。如果一个类的\<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞。  
 
[toTop](#jump)

# 类加载器
## 类与类加载器
Java程序一般会使用到以下三种系统提供的类加载器：
1) 启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库到JVM内存中，如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。
2) 扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\lib\，该加载器可以被开发者直接使用。
3) 应用程序类加载器（Application ClassLoader）：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
## 双亲委派模型
![](/img/Parents_Delegation_Model.jpg)
双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。   
使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。
源代码如下

```java
    protected synchronized Class loadClass(String name, boolean resolve)  
            throws ClassNotFoundException {  
        // 首先检查该name指定的class是否有被加载  
        Class c = findLoadedClass(name);  
        if (c == null) {  
            try {  
                if (parent != null) {  
                    // 如果parent不为null，则调用parent的loadClass进行加载  
                    c = parent.loadClass(name, false);  
                } else {  
                    // parent为null，则调用BootstrapClassLoader进行加载  
                    c = findBootstrapClass0(name);  
                }  
            } catch (ClassNotFoundException e) {  
                // 如果仍然无法加载成功，则调用自身的findClass进行加载  
                c = findClass(name);  
            }  
        }  
        if (resolve) {  
            resolveClass(c);  
        }  
        return c;  
    }  
```

[toTop](#jump)

# java内存区域
![](/img/java_memory.jpg)
![](/img/java_memory2.jpg)  

[toTop](#jump)

# 堆，栈，方法区存储内容
* 栈区: 
1) **每个线程包含一个栈区**，栈中只保存方法中（不包括对象的成员变量）的**基础数据类型和自定义对象的引用(不是对象**，对象都存放在堆区中
2) 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
3) 栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
* 堆区: 
1) 存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。
2) **jvm只有一个堆区(heap)被所有线程共享**，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的**对象实例和数组**都在堆中分配。
* 方法区: 又叫静态区，跟堆一样，被所有的线程共享。它用于存储**已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等**数据。   

[toTop](#jump)

# 垃圾回收
## 如何确定某个对象是“垃圾”
Java中采取了**可达性分析法**。该方法的基本思想是通过一系列的“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。  
**GC ROOT**包括：
1) 虚拟机栈（栈中的本地变量表）中引用的对象；
2) 方法区中类静态属性引用的对象；
3) 方法区中常量引用的对象；
4) 本地方法栈中JNI（即一般说的Native方法）引用的对象。
## 典型的垃圾收集算法
1) 标记-清除算法（Mark-Sweep)
首先标记出需要回收的对象，在标记完成后统一回收掉所有的被标记对象。  
缺点：效率问题和空间问题（标记清除后会产生大量的不连续内存碎片，内存碎片过多可能会导致程序需要分配较大对象时找不到足够大的连续内存空间而不得不提前触发另一次垃圾回收动作）
![](/img/mark_sweep.png)
2) 复制算法（Copying)
将内存划分为大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将还存活的对象复制到另一块内存上，然后把已使用过的内存空间一次清理掉。   
优点：每次只对其中一块进行GC,不用考虑内存碎片的问题，并且实现简单，运行高效   
缺点：内存缩小了一半
![](/img/copying.png)
注：现在的商业虚拟机都是用这种收集算法回收新生代。内存分为一块较大的Eden空间和两块较小的Survior空间，每次使用Eden和其中的一块Survior.当回收时，将Eden和Survior中还存活的对象一次性拷贝到另外一块Survior空间上，最后清理Eden和刚才用过的Survior空间。
3) 标记-整理算法（Mark-Compact
让所有存活对象都向一端移动，然后直接清理掉端边界以外的所有内存。
![](/img/mark_compact.png)
4) 分代收集算法（Generational Collection）
根据对象的存活周期的不同将内存划分为几块，一般就分为新生代和老年代，根据各个年代的特点采用不同的收集算法。新生代（少量存活）用复制算法，老年代（对象存活率高）“标记-清理”算法   
整个JVM内存总共划分为三代：年轻代、年老代、持久代
* 年轻代：所有新生成的对象首先都放在年轻代内存中。年轻代的目标就是尽可能快速的手机掉那些生命周期短的对象。年轻代内存分为一块较大的Eden空间和两块较小的Survior空间，每次使用Eden和其中的一块Survior.当回收时，将Eden和Survior中还存活的对象一次性拷贝到另外一块Survior空间上，最后清理Eden和刚才用过的Survior空间。
* 年老代：在年轻代经历了N次GC后，仍然存活的对象，就会被放在老年代中。因此可以认为老年代存放的都是一些生命周期较长的对象。
* 持久代：基本固定不变，用于存放静态文件，例如Java类和方法。持久代对GC没有显著的影响。持久代可以通过-XX:MaxPermSize=<N>进行设置。**(java8中永久代废弃，以metaspace代替。metaspace使用本地内存。)**  
  
[toTop](#jump)

# 常用JVM优化参数
```
-Xmx
　　指定java程序的最大堆内存, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存   

-Xms
　　指定最小堆内存, 通常设置成跟最大堆内存一样，减少GC

-Xmn
　　设置年轻代大小为512m。整个堆大小=年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。

-Xss
　　指定线程的最大栈空间, 此参数决定了java函数调用的深度, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)
设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程 大约需要占用多少内存，可能会有多少线程同时运行等。一般不易设置超过1M，要不然容易出现out of memory

-XX:PermSize
　　指定方法区(永久区)的初始值,默认是物理内存的1/64， 在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定

-XX:MaxPermSize
　　指定方法区的最大值, 默认是物理内存的1/4，在java8中由-XX:MaxMetaspaceSize指定元数据区的大小
```

[toTop](#jump)

# JAVA 内存模型
　java虚拟机有自己的内存模型（Java Memory Model，JMM），JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。

　　JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。这三者之间的交互关系如下

![](/img/JMM.png)

JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。

[toTop](#jump)

# 内存溢出和内存泄漏

* 内存泄漏：**分配出去的内存无法回收**（不再使用的对象或者变量仍占内存空间），在Java中内存泄漏就是存在一些被分配的对象（可达的，却是无用的）无法被gc回收。

* 内存溢出：**程序要求的内存超出了系统所能分配的范围**（比如：栈满还入栈 出现上溢，栈空还出栈 出现下溢）

可以看出内存泄漏是内存溢出的一种诱因，但不是唯一因素。

内存泄漏的两种情况：
1) 堆中申请的内存没释放；
2) 对象已不再使用，但还在内存中保留着。

Gc可以有效的解决第一种情况，但是无法保证情况二，所以**Java存在的内存泄漏主要是第二种**。

## 内存泄露的几种场景

1) 长生命周期的对象持有短生命周期对象的引用，即**静态集合类**。例如：在static HashMap中缓存局部变量，且没清空，随时间的推移，这个map会越来越大，造成内存泄露。

2) **变量不合理的作用域**。

3) **没有及时的将对象设置为null**

4) **各种连接没显示关闭**。数据库连接、网络连接、IO连接，没显示的close，会造成很多对象无法回收。

5) **监听器**。释放对象时没有删除监听器。

6) **不正确使用单例模式**

## 避免内存泄漏

1) 尽早释放无用对象的引用

2) 使用字符串处理，避免使用String，应大量使用StringBuffer，每一个String对象都得独立占用内存一块区域

3) 尽量少用静态变量，因为静态变量存放在永久代（方法区）

4) 不要在经常调用的方法中创建对象，尤其忌讳在循环中创建对象
可以适当的使用hashtable，vector创建一组对象容器，然后从容器中去取这些对象，而不用每次new之后又丢弃。

5) 开启大型文件或从数据库一次拿了太多的数据很容易造成内存溢出，所以在这些地方要大概计算一下数据量的最大值是多少，并且设定所需最小及最大的内存空间值。

## 内存溢出

### 堆内存溢出
申请了很多内存，没释放

### 方法区内存溢出
方法区主要存放的是类信息、常量、静态变量等。所以如果程序加载的类过多，或者使用反射、gclib等这种动态代理生成类的技术，就可能导致该区发生内存溢出

### 线程栈溢出
线程栈时线程独有的一块内存结构，所以线程栈发生问题必定是某个线程运行时产生的错误。 一般线程栈溢出是由于递归太深或方法调用层级过多导致的。

参考1 : [内存泄漏和内存溢出](https://blog.csdn.net/u012813201/article/details/73793668)

参考2 : [【Java JVM】如何避免内存泄漏、溢出](https://blog.csdn.net/u013177446/article/details/53941021)

参考3 : [常见的内存泄漏原因及解决方法](https://www.jianshu.com/p/90caf813682d)

[toTop](#jump)

# 垃圾收集器

## G1

### 基础知识
1) 初衷
在G1提出之前，经典的垃圾收集器主要有三种类型：串行收集器、并行收集器和并发标记清除收集器，这三种收集器分别可以是满足Java应用三种不同的需求：内存占用及并发开销最小化、应用吞吐量最大化和应用GC暂停时间最小化，但是，上述三种垃圾收集器都有几个共同的问题：（1）所有针对老年代的操作必须**扫描整个老年代空间**；（2）新生代和老年代是独立的连续的内存块，**必须先决定年轻代和老年代在虚拟地址空间的位置**。

2) 设计目标
G1是一种服务端应用使用的垃圾收集器，目标是用在多核、大内存的机器上，它在大多数情况下可以实现指定的GC暂停时间，同时还能保持较高的吞吐量。

3) 使用场景
G1适用于以下几种应用：
可以像CMS收集器一样，允许垃圾收集线程和应用线程并行执行，即**需要额外的CPU资源；**
**压缩空闲空间不会延长GC的暂停时间；**
**需要更易预测的GC暂停时间；**
**不需要实现很高的吞吐量**

### G1的重要概念

1. 分区（Region）
G1采取了不同的策略来解决并行、串行和CMS收集器的碎片、暂停时间不可控制等问题——G1将整个堆分成相同大小的分区（Region）

![](/img/g1_heap.jpg)

有的分区内垃圾对象特别多，有的分区内垃圾对象很少，G1会**优先回收垃圾对象特别多的分区**，这样可以花费较少的时间来回收这些分区的垃圾

G1还是一种**带压缩**的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个可用分区，这个拷贝的过程就实现了局部的压缩。每个分区的大小从1M到32M不等，但是**都是2的冥次方**。

2. 收集集合（CSet）
一组可被回收的分区的集合。

3. 已记忆集合（RSet）
RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。

![](/img/g1_rset.jpg)

(GC则是在points-out的card table之上再加了一层结构来构成points-into RSet：每个region会记录下到底哪些别的region有指向自己的指针，而这些指针分别在哪些card的范围内。 这个RSet其实是一个hash table，key是别的region的起始地址，value是一个集合，里面的元素是card table的index。 举例来说，如果region A的RSet里有一项的key是region B，value里有index为1234的card，它的意思就是region B的一个card里有引用指向region A。所以对region A来说，该RSet记录的是points-into的关系；而card table仍然记录了points-out的关系。)

4. Snapshot-At-The-Beginning(SATB)
G1 GC的并发理论基础就是SATB，SATB是由Taiichi Yuasa为增量式标记清除垃圾收集器设计的一个标记算法
CMS的incremental update设计使得它在remark阶段必须重新扫描所有线程栈和整个young gen作为root；G1的SATB设计在remark阶段则只需要扫描剩下的satb_mark_queu
**问题1** SATB是一个快照标记算法，在并发标记进行的过程中，垃圾收集器（Collecotr）和应用程序（Mutator）都在活动，如果一个对象还没被mark到，这时候Mutator就修改了它的引用，那么这时候拿到的快照就是不完整的了，如何解决这个问题呢?
G1 GC使用了SATB write barrier来解决这个问题——在并发标记过程中，将该对象的旧的引用记录在一个SATB日志对列或缓冲区中。

### G1的过程
G1收集器的收集活动主要有四种操作：

* 新生代垃圾收集
* 后台收集、并发周期
* 混合式垃圾收集
* 必要时候的Full GC

![](/img/g1_eden_recycle.jpg)
Eden区耗尽的时候就会触发新生代收集，新生代垃圾收集会对**整个新生代进行回收**
新生代垃圾收集期间，**整个应用STW**
新生代垃圾收集是由**多线程并发执行**的
新生代收集结束后**依然存活的对象，会被拷贝到一个新的Survivor分区，或者是老年代**。

G1设计了一个标记阈值，它描述的是总体Java堆大小的百分比，默认值是45，这个值可以通过命令
```java
-XX:InitiatingHeapOccupancyPercent(IHOP)
```

来调整，一旦达到这个阈值就回触发一次并发收集周期。

![](/img/g1_mark_recycle.jpg)
在上图中有几个情况需要注意：

1、新生代的空间占用情况发生了变化——在并发收集周期中，至少有一次（很可能是多次）新生代垃圾收集；
2、注意到一些分区被标记为X，这些分区属于老年代，它们就是标记周期找出的包含最多垃圾的分区（注意：它们内部仍然保留着数据）；
3、老年代的空间占用在标记周期结束后变得更多，这是因为在标记周期期间，新生代的垃圾收集会晋升对象到老年代，而且标记周期中并不会回收
老年代的任何对象。

**G1的并发标记周期包括多个阶段**

1、**初始标记（initial-mark）**，在这个阶段，应用会经历STW，通常初始标记阶段会跟一次新生代收集一起进行，换句话说——既然这两个阶段**都需要暂停应用**，G1 GC就重用了新生代收集来完成初始标记的工作。

2、**根分区扫描（root-region-scan），这个过程不需要暂停应用**，在初始标记或新生代收集中被拷贝到survivor分区的对象，都需要被看做是根，这个阶段G1开始扫描survivor分区，所有被survivor分区所引用的对象都会被扫描到并将被标记。

survivor分区就是根分区，正因为这个，该阶段不能发生新生代收集，如果扫描根分区时，新生代的空间恰好用尽，新生代垃圾收集必须等待根分区扫描结束才能完成。**如果在日志中发现根分区扫描和新生代收集的日志交替出现，就说明当前应用需要调优**。

3、**并发标记阶段（concurrent-mark）**，并发标记阶段是多线程的，我们可以通过```-XX:ConcGCThreads```来设置并发线程数，默认情况下，G1垃圾收集器会将这个线程总数设置为并行垃圾线程数```-XX:ParallelGCThreads```
的四分之一；并发标记会利用trace算法找到所有活着的对象，并记录在一个bitmap中，因为在TAMS之上的对象都被视为隐式存活，因此我们只需要遍历那些在TAMS之下的；

4、**重新标记阶段（remarking）**，重新标记阶段是最后一个标记阶段，需要暂停整个应用，G1垃圾收集器会处理掉剩下的SATB日志缓冲区和所有更新的引用，同时G1垃圾收集器还会找出所有未被标记的存活对象。这个阶段还会负责引用处理等工作。

5、**清理阶段（cleanup）**，清理阶段真正回收的内存很小，截止到这个阶段,G1垃圾收集器主要是标记处哪些老年代分区可以回收，将老年代按照它们的存活度（liveness）从小到大排列。

混合收集只会回收一部分老年代分区
![](/img/g1_mix_recycle.jpg)
混合收集会执行多次，一直运行到（几乎）所有标记点老年代分区都被回收，在这之后就会恢复到常规的新生代垃圾收集周期。当整个堆的使用率超过指定的百分比时，G1 GC会启动新一轮的并发标记周期。在混合收集周期中，**对于要回收的分区，会将该分区中存活的数据拷贝到另一个分区**，这也是为什么G1收集器最终出现碎片化的频率比CMS收集器小得多的原因——**以这种方式回收对象，实际上伴随着针对当前分区的压缩**。


### 两个模式
G1收集器的模式主要有两种：

1) Young GC（新生代垃圾收集）
2) Mixed GC（混合垃圾收集）

![](/img/g1_stw_process.jpg)

### 巨型对象的管理
在G1中，如果**一个对象的大小超过分区大小的一半，该对象就被定义为巨型对象（Humongous Object）**。巨型对象时直接分配到老年代分区，如果一个对象的大小**超过一个分区的大小，那么会直接在老年代分配两个连续的分区来存放该巨型对象**。巨型分区一定是连续的，分配之后也不会被移动——没啥益处。

### G1执行过程中的异常情况

1) G1启动了标记周期，但是在并发标记完成之前，就发生了Full GC，日志常常如下所示

```java
51.408: [GC concurrent-mark-start]
65.473: [Full GC 4095M->1395M(4096M), 6.1963770 secs]
 [Times: user=7.87 sys=0.00, real=6.20 secs]
71.669: [GC concurrent-mark-abort]
```

GC concurrent-mark-start开始之后就发生了FULL GC，这说明针对老年代分区的回收速度比较慢，或者说对象过快得从新生代晋升到老年代，或者说是有很多大对象直接在老年代分配。针对上述原因，我们可能需要做的调整有：调大整个堆的大小、更快得触发并发回收周期、让更多的回收线程参与到垃圾收集的动作中。

2) 混合收集模式中的FULL GC
在GC日志中观察到，在一次混合收集之后跟着一条FULL GC，这意味着混合收集的速度太慢，在老年代释放出足够多的分区之前，应用程序就来请求比当前剩余可分配空间大的内存。针对这种情况我们可以做的调整：增加每次混合收集收集掉的老年代分区个数；增加并发标记的线程数；提高混合收集发生的频率。

3) 疏散失败（转移失败）
在新生代垃圾收集快结束时，找不到可用的分区接收存活下来的对象，常见如下的日志：

```java
60.238: [GC pause (young) (to-space overflow), 0.41546900 secs]
```

这意味着整个堆的碎片化已经非常严重了，我们可以从以下几个方面调整：（1）增加整个堆的大小——通过增加```-XX:G1ReservePercent```
选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量;（2）通过减少 ```-XX:InitiatingHeapOccupancyPercent```提前启动标记周期；（3）
你也可以通过增加```-XX:ConcGCThreads```选项的值来增加并发标记线程的数目

4) 巨型对象分配失败
如果在GC日志中看到莫名其妙的FULL GC日志，又对应不到上述讲过的几种情况，那么就可以怀疑是巨型对象分配导致的，这里我们可以考虑使用```jmap```命令进行堆dump，然后通过MAT对堆转储文件进行分析。

### G1的调优
G1的调优目标主要是在避免FULL GC和疏散失败的前提下，尽量实现较短的停顿时间和较高的吞吐量。关于G1 GC的调优，需要记住以下几点：

1、不要自己显式设置新生代的大小（用```Xmn```或```-XX:NewRatio```参数），如果显式设置新生代的大小，会导致目标时间这个参数失效。

2、由于G1收集器自身已经有一套预测和调整机制了，因此我们首先的选择是相信它，即调整```-XX:MaxGCPauseMillis=N```参数，这也符合G1的目的——让GC调优尽量简单，这里有个取舍：如果减小这个参数的值，就意味着会调小新生代的大小，也会导致新生代GC发生得更频繁，同时，还会导致混合收集周期中回收的老年代分区减少，从而增加FULL GC的风险。这个时间设置得越短，应用的吞吐量也会受到影响。

3、针对混合垃圾收集的调优。如果调整这期望的最大暂停时间这个参数还是无法解决问题，即在日志中仍然可以看到FULL GC的现象，那么就需要自己手动做一些调整，可以做的调整包括：

1）调整G1垃圾收集的后台线程数，通过设置```-XX:ConcGCThreads=n```这个参数，可以增加后台标记线程的数量；

2）调整G1垃圾收集器并发周期的频率，如果让G1更早得启动垃圾收集，也可以帮助G1赢得这场比赛，那么可以通过设置```-XX:InitiatingHeapOccupancyPercent```这个参数来实现这个目标，如果将这个参数调小，G1就会更早得触发并发垃圾收集周期。

这个值需要谨慎设置：如果这个参数设置得太高，会导致FULL GC出现得频繁；如果这个值设置得过小，又会导致G1频繁得进行并发收集，白白浪费CPU资源。通过GC日志可以通过一个点来判断GC是否正常——在一轮并发周期结束后，需要确保堆剩下的空间小于InitiatingHeapOccupancyPercent的值。

3）调整G1垃圾收集器的混合收集的工作量，即在一次混合垃圾收集中尽量多处理一些分区，可以从另外一方面提高混合垃圾收集的频率。在一次混合收集中可以回收多少分区，取决于三个因素：

（1）有多少个分区被认定为垃圾分区，```-XX:G1MixedGCLiveThresholdPercent=n```这个参数表示如果一个分区中的存活对象比例超过n，就不会被挑选为垃圾分区，因此可以通过这个参数控制每次混合收集的分区个数，这个参数的值越大，某个分区越容易被当做是垃圾分区；

（2）G1在一个并发周期中，最多经历几次混合收集周期，这个可以通过```-XX:G1MixedGCCountTarget=n```设置，默认是8，如果减小这个值，可以增加每次混合收集收集的分区数，但是可能会导致停顿时间过长；

（3）期望的GC停顿的最大值，由```MaxGCPauseMillis```参数确定，默认值是200ms，在混合收集周期内的停顿时间是向上规整的，如果实际运行时间比这个参数小，那么G1就能收集更多的分区。

### G1的最佳实践
1. 关键参数项
```-XX:+UseG1GC```，告诉JVM使用G1垃圾收集器
```-XX:MaxGCPauseMillis=200```，设置GC暂停时间的目标最大值，这是个柔性的目标，JVM会尽力达到这个目标
```-XX:INitiatingHeapOccupancyPercent=45```，如果整个堆的使用率超过这个值，G1会触发一次并发周期。记住这里针对的是整个堆空间的比例，而不是某个分代的比例。
2. 最佳实践
不要设置年轻代的大小
通过```-Xmn```显式设置年轻代的大小，会干扰G1收集器的默认行为：

G1不再以设定的暂停时间为目标，换句话说，如果设置了年轻代的大小，就无法实现自适应的调整来达到指定的暂停时间这个目标
G1不能按需扩大或缩小年轻代的大小

响应时间度量
不要根据平均响应时间（ART）来设置```-XX:MaxGCPauseMillis=n```这个参数，应该设置希望90%的GC都可以达到的暂停时间。这意味着90%的用户请求不会超过这个响应时间，记住，这个值是一个目标，但是G1并不保证100%的GC暂停时间都可以达到这个目标

![](/img/g1_parameters.png)
![](/img/g1_parameters2.png)

### 常见问题
1、Young GC、Mixed GC和Full GC的区别？
答：Young GC的CSet中只包括年轻代的分区，Mixed GC的CSet中除了包括年轻代分区，还包括老年代分区；Full GC会暂停整个引用，同时对新生代和老年代进行收集和压缩。

2、ParallelGCThreads和ConcGCThreads的区别？
答：ParallelGCThreads指得是在STW阶段，并行执行垃圾收集动作的线程数，ParallelGCThreads的值一般等于逻辑CPU核数，如果CPU核数大于8，则设置为```5/8 * cpus```，在SPARC等大型机上这个系数是5/16。；ConcGCThreads指的是在并发标记阶段，并发执行标记的线程数，一般设置为ParallelGCThreads的四分之一。

3、write barrier在GC中的作用？如何理解G1 GC中write barrier的作用？
写屏障是一种内存管理机制，用在这样的场景——当代码尝试修改一个对象的引用时，在前面放上写屏障就意味着将这个对象放在了写屏障后面。

write barrier在GC中的作用有点复杂，我们这里以trace GC算法为例讲下：trace GC有些算法是并发的，例如CMS和G1，即用户线程和垃圾收集线程可以同时运行，即mutator一边跑，collector一边收集。这里有一个限制是：黑色的对象不应该指向任何白色的对象。如果mutator视图让一个黑色的对象指向一个白色的对象，这个限制就会被打破，然后GC就会失败。

针对这个问题有两种解决思路：

（1）通过添加read barriers阻止mutator看到白色的对象；

（2）通过write barrier阻止mutator修改一个黑色的对象，让它指向一个白色的对象。write barrier的解决方法就是讲黑色的对象放到写write barrier后面。如果真得发生了white-on-black这种写需求，一般也有多种修正方法：增量得将白色的对象变灰，将黑色的对象重新置灰等等。

增量的变灰就是CMS和G1里并发标记的过程，将黑色的对象重新变灰就是利用卡表或SATB的缓冲区将黑色的对象重新置灰的过程，当然会在重新标记中将所有灰色的对象处理掉。关于G1中write barrier的作用，可以参考R大的这个帖子里提到的：

![](/img/g1_write_barrier.jpg)
4、G1里在并发标记的时候，如果有对象的引用修改，要将旧的值写到一个缓冲区中，这个动作前后会有一个write barrier，这段可否细说下？

答：这块涉及到SATB标记算法的原理，SATB是指start at the beginning，即在并发收集周期的第一个阶段（初始标记）是STW的，会给所有的分区做个快照，后面的扫描都是按照这个快照进行；在并发标记周期的第二个阶段，并发标记，这是收集线程和应用线程同时进行的，这时候应用线程就可能修改了某些引用的值，导致上面那个快照不是完整的，因此G1就想了个办法，我把在这个期间对对象引用的修改都记录动作都记录下来，有点像mysql的操作日志。

5、GC算法中的三色标记算法怎么理解？
trace GC将对象分为三类：白色（垃圾收集器未探测到的对象）、灰色（活着的对象，但是依然没有被垃圾收集器扫描过）、黑色（活着的对象，并且已经被垃圾收集器扫描过）。垃圾收集器的工作过程，就是通过灰色对象的指针扫描它指向的白色对象，如果找到一个白色对象，就将它设置为灰色，如果某个灰色对象的可达对象已经全部找完，就将它设置为黑色对象。当在当前集合中找不到灰色的对象时，就说明该集合的回收动作完成，然后所有白色的对象的都会被回收。


参考 : [可能是最全面的 Java G1学习笔记](https://mp.weixin.qq.com/s/Shw0jtVse1QqNbFCyYmfZA)

[toTop](#jump)


## CMS

### 基础知识
CMS收集器：Mostly-Concurrent收集器，也称并发标记清除收集器（Concurrent Mark-Sweep GC，CMS收集器），它管理新生代的方式与Parallel收集器和Serial收集器相同，而在老年代则是尽可能得并发执行，每个垃圾收集器周期只有2次短停顿。

CMS的**初衷和目的**：为了消除Throught收集器和Serial收集器在Full GC周期中的长时间停顿。

CMS的**适用场景**：如果你的应用需要更快的响应，不希望有长时间的停顿，同时你的CPU资源也比较丰富，就适合适用CMS收集器。

### CMS的过程
1、（STW）初始标记：这个阶段是标记从GcRoots直接可达的老年代对象、新生代引用的老年代对象，就是下图中灰色的点。这个过程是单线程的（JDK7之前单线程，JDK8之后并行，可以通过参数CMSParallelInitialMarkEnabled调整）
![](/img/cms_mark.jpg)

2、并发标记：由上一个阶段标记过的对象，开始tracing过程，标记所有可达的对象，这个阶段垃圾回收线程和应用线程同时运行，如上图中的灰色的点。在并发标记过程中，应用线程还在跑，因此会导致有些对象会从新生代晋升到老年代、有些老年代的对象引用会被改变、有些对象会直接分配到老年代，这些受到影响的老年代对象所在的card会被标记为dirty，用于重新标记阶段扫描。这个阶段过程中，老年代对象的card被标记为dirty的可能原因，就是下图中绿色的线：
![](/img/cms_concurrence_mark.jpg)

3、预清理：预清理，也是用于标记老年代存活的对象，目的是为了让重新标记阶段的STW尽可能短。这个阶段的目标是在并发标记阶段被应用线程影响到的老年代对象，包括：（1）老年代中card为dirty的对象；（2）幸存区(from和to)中引用的老年代对象。因此，这个阶段也需要扫描新生代+老年代。

4、可中断的预清理：这个阶段的目标跟“预清理”阶段相同，也是为了减轻重新标记阶段的工作量。

5、 （STW）重新标记：重新扫描堆中的对象，进行可达性分析,标记活着的对象。

6、并发清除：用户线程被重新激活，同时将那些未被标记为存活的对象标记为不可达；

7、 并发重置：CMS内部重置回收器状态，准备进入下一个并发回收周期。

### CMS的异常情况

上面描述的是CMS的并发周期正常完成的情况，但是还有几种CMS并发周期失败的情况：

1、并发模式失败（Concurrent mode failure）：CMS的目标就是在回收老年代对象的时候不要停止全部应用线程，在并发周期执行期间，用户的线程依然在运行，如果这时候如果应用线程向老年代请求分配的空间超过预留的空间（担保失败），就回触发concurrent mode failure，然后CMS的并发周期就会被一次Full GC代替——停止全部应用进行垃圾收集，并进行空间压缩。如果我们设置了```UseCMSInitiatingOccupancyOnly```和```CMSInitiatingOccupancyFraction```参数，其中```CMSInitiatingOccupancyFraction```的值是70，那预留空间就是老年代的30%。

2、 晋升失败：新生代做minor gc的时候，需要CMS的担保机制确认老年代是否有足够的空间容纳要晋升的对象，担保机制发现不够，则报concurrent mode failure，如果担保机制判断是够的，但是实际上由于碎片问题导致无法分配，就会报晋升失败。

3、 永久代空间（或Java8的元空间）耗尽，默认情况下,CMS不会对永久代进行收集，一旦永久代空间耗尽，就回触发Full GC。

### CMS的调优

1、 针对停顿时间过长的调优

首先需要判断是哪个阶段的停顿导致的，然后再针对具体的原因进行调优。使用CMS收集器的JVM可能引发停顿的情况有：

（1）Minor gc的停顿；
（2）并发周期里初始标记的停顿；
（3）并发周期里重新标记的停顿；
（4）Serial-Old收集老年代的停顿；
（5）Full GC的停顿。其中并发模式失败会导致第（4）种情况，晋升失败和永久代空间耗尽会导致第（5）种情况。

2、 针对并发模式失败的调优

想办法增大老年代的空间，增加整个堆的大小，或者减少年轻代的大小

以更高的频率执行后台的回收线程，即提高CMS并发周期发生的频率。设置```UseCMSInitiatingOccupancyOnly```和```CMSInitiatingOccupancyFraction```参数，调低```CMSInitiatingOccupancyFraction```的值，但是也不能调得太低，太低了会导致过多的无效的并发周期，会导致消耗CPU时间和更多的无效的停顿。

增多回收线程的个数
CMS默认的垃圾收集线程数是```（CPU个数 + 3）/4```，这个公式的含义是：当CPU个数大于4个的时候，垃圾回收后台线程至少占用25%的CPU资源。举个例子：如果CPU核数是1-4个，那么会有1个CPU用于垃圾收集，如果CPU核数是5-8个，那么久会有2个CPU用于垃圾收集。

3、 针对永久代的调优

如果永久代需要垃圾回收（或元空间扩容），就会触发Full GC。默认情况下，CMS不会处理永久代中的垃圾，可以通过开启```CMSPermGenSweepingEnabled```配置来开启永久代中的垃圾回收，开启后会有一组后台线程针对永久代做收集，需要注意的是，触发永久代进行垃圾收集的指标跟触发老年代进行垃圾收集的指标是独立的，老年代的阈值可以通过```CMSInitiatingPermOccupancyFraction```参数设置，这个参数的默认值是```80%```。开启对永久代的垃圾收集只是其中的一步，还需要开启另一个参数——```CMSClassUnloadingEnabled```，使得在垃圾收集的时候可以卸载不用的类。


### CMS优劣点
1、 优势

低延迟的收集器：几乎没有长时间的停顿，应用程序只在Minor gc以及后台线程扫描老年代的时候发生极其短暂的停顿。

2、 劣势

更高的CPU使用：必须有足够的CPU资源用于运行后台的垃圾收集线程，在应用程序线程运行的同时扫描堆的使用情况。【PS：现在服务器的CPU资源基本不是问题，这个点可以忽略】

CMS收集器对老年代收集的时候，不再进行任何压缩和整理的工作，意味着老年代随着应用的运行会变得碎片化；碎片过多会影响大对象的分配，虽然老年代还有很大的剩余空间，但是没有连续的空间来分配大对象，这时候就会触发Full GC。CMS提供了两个参数来解决这个问题：（1）```UseCMSCompactAtFullCollection```，在要进行Full GC的时候进行内存碎片整理；（2）```CMSFullGCsBeforeCompaction```，每隔多少次不压缩的Full GC后，执行一次带压缩的Full GC。

会出现浮动垃圾；在并发清理阶段，用户线程仍然在运行，必须预留出空间给用户线程使用，因此CMS比其他回收器需要更大的堆空间。

### 问题
1、为什么ParNew可以和CMS配合使用，而Parallel Scanvenge不可以？

这个跟Hotspot VM的历史有关，Parallel Scanvenge是不在“分代框架”下开发的，而ParNew、CMS都是在分代框架下开发的。

2、CMS中minor gc和major gc是顺序发生的吗？

不是的，可以交叉发生，即在并发周期执行过程中，是可以发生Minor gc的，这个找个gc日志就可以观察到。

3、CMS的并发收集周期合适触发？

* 阈值检查机制：老年代的使用空间达到某个阈值，JVM的默认值是92%（jdk1.5之前是68%，jdk1.6之后是92%），或者可以通过CMSInitiatingOccupancyFraction和UseCMSInitiatingOccupancyOnly两个参数来设置；这个参数的设置需要看应用场景，设置得太小，会导致CMS频繁发生，设置得太大，会导致过多的并发模式失败。例如

* 动态检查机制：JVM会根据最近的回收历史，估算下一次老年代被耗尽的时间，快到这个时间的时候就启动一个并发周期。设置UseCMSInitiatingOccupancyOnly这个参数可以将这个特性关闭。


4、CMS的并发收集周期会扫描哪些对象？会回收哪些对象？

CMS的并发周期只会回收老年代的对象，但是在标记老年代的存活对象时，可能有些对象会被年轻代的对象引用，因此需要扫描整个堆的对象。

5、CMS的gc roots包括哪些对象？

首先，在JVM垃圾收集中Gc Roots的概念如何理解(参见R大对GC roots的概念的解释)；第二，CMS的并发收集周期中，如何判断老年代的对象是活着？我们前面提到了，在CMS的并发周期中，仅仅扫描Gc Roots直达的对象会有遗漏，还需要扫描新生代的对象。如下图中的蓝色字体所示，CMS中的年轻代和老年代是分别收集的，因此在判断年轻代的对象存活的时候，需要把老年代当作自己的GcRoots，这时候并不需要扫描老年代的全部对象，而是使用了card table数据结构，如果一个老年代对象引用了年轻代的对象，则card中的值会被设置为特殊的数值；反过来判断老年代对象存活的时候，也需要把年轻代当作自己的Gc Roots

6、如果我的应用决定使用CMS收集器，推荐的JVM参数是什么？

参考
```java
-Xmx4096M -Xms4096M -Xmn1536M 
-XX:MaxMetaspaceSize=512M -XX:MetaspaceSize=512M 
-XX:+UseConcMarkSweepGC 
-XX:+UseCMSInitiatingOccupancyOnly 
-XX:CMSInitiatingOccupancyFraction=70 
-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses 
-XX:+CMSClassUnloadingEnabled 
-XX:+ParallelRefProcEnabled 
-XX:+CMSScavengeBeforeRemark 
-XX:ErrorFile=/home/admin/logs/xelephant/hs_err_pid%p.log 
-Xloggc:/home/admin/logs/xelephant/gc.log 
-XX:HeapDumpPath=/home/admin/logs/xelephant 
-XX:+PrintGCDetails 
-XX:+PrintGCDateStamps 
-XX:+HeapDumpOnOutOfMemoryError
```

7.什么情况下才选择使用CMS收集器呢？

* 小于8G的都用CMS，大于8G的选择G1。

* 除了看吞吐量和延时，还需要看具体的应用，比方说ES，Lucene和G1是不兼容的，因此默认的收集器就是CMS。

* 小于3G的堆，如果不是对延迟有特别高的需求，不建议使用CMS，主要是由于CMS的几个缺点导致的：（1）并发周期的触发比例不好设置；（2）抢占CPU时间；（3）担保判断导致YGC变慢；（4）碎片问题。

8.promotion failed和concurrent mode failure的触发原因有啥不同？

* promotion failed是说，担保机制确定老年代是否有足够的空间容纳新来的对象，如果担保机制说有，但是真正分配的时候发现由于碎片导致找不到连续的空间而失败；

* concurrent mode failure是指并发周期还没执行完，用户线程就来请求比预留空间更大的空间了，即后台线程的收集没有赶上应用线程的分配速度。

9.concurrent mode failure和promotion failed触发的Full GC有啥不同?

concurrent mode failure触发的"Full GC"不是我们常说的Full GC——正常的Full GC其实是整个gc过程包括ygc和cms gc。也就是说，这个问题本身是有问题的，concurrent mode failure的时候触发的并不是我们常说的Full GC。然后再去讨论一个遗漏的知识点：CMS gc的并发周期有两种模式：**foreground**和**background**。

concurrent mode failure触发的是foreground模式，会暂停整个应用，会将一些并行的阶段省掉做一次老年代收集，行为跟Serial-Old的一样，至于在这个过程中是否需要压缩，则需要看三个条件：

* 我们设置了```UseCMSCompactAtFullCollection```和```CMSFullGCsBeforeCompaction```，前者设置为true，后者默认是0，前者表示是在Full GC的时候执行压缩，后者表示是每隔多少个进行压缩，默认是0的话就是每次Full GC都压缩；

* 用户调用了System.gc()，而且DisableExplicitGC没有开启；

* young gen报告接下来如果做增量收集会失败。


promotion failed触发的是我们常说的的Full GC，对年轻代和老年代都会回收，并进行整理。


参考 ：[深入浅出 Java CMS 学习笔记](https://mp.weixin.qq.com/s/eGwLVk474cJWyVoP97gWGg)


[toTop](#jump)
