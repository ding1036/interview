<a id = "jump">[首页](/README.md)</a>
<!-- TOC -->

- [class.forName()和classLoader.loadClass()区别](#classforname和classloaderloadclass区别)
- [数据库链接为什么使用Class.forName(className)](#数据库链接为什么使用classfornameclassname)
- [类加载过程](#类加载过程)
    - [加载：（重点）](#加载重点)
    - [验证：（了解）](#验证了解)
    - [准备：（了解）](#准备了解)
    - [解析：（了解）](#解析了解)
- [类加载器](#类加载器)
    - [类与类加载器](#类与类加载器)
    - [双亲委派模型](#双亲委派模型)
- [java内存区域](#java内存区域)
- [堆，栈，方法区存储内容](#堆栈方法区存储内容)
- [垃圾回收](#垃圾回收)
    - [如何确定某个对象是“垃圾”](#如何确定某个对象是垃圾)
    - [典型的垃圾收集算法](#典型的垃圾收集算法)
- [常用JVM优化参数](#常用jvm优化参数)

<!-- /TOC -->
# class.forName()和classLoader.loadClass()区别
Class.forName(className)方法，内部实际调用的方法是  Class.forName(className,true,classloader);第2个boolean参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。一旦初始化，就会触发目标对象的 static块代码执行，static参数也也会被再次初始化。  
ClassLoader.loadClass(className)方法，内部实际调用的方法是  ClassLoader.loadClass(className,false);不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行.
class.forName()除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。  
Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象  
[toTop](#jump)

# 数据库链接为什么使用Class.forName(className)
JDBC  Driver源码如下,因此使用Class.forName(classname)才能在反射回去类的时候执行static块。
```
static {
    try {
        java.sql.DriverManager.registerDriver(new Driver());
    } catch (SQLException E) {
        throw new RuntimeException("Can't register driver!");
    }
}
```
[toTop](#jump)

# 类加载过程
![](/img/class_loader_process.jpg)
## 加载：（重点）
加载阶段是“类加载机制”中的一个阶段，这个阶段通常也被称作“装载”，主要完成：
1.通过“类全名”来获取定义此类的二进制字节流
2.将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3.在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口   
相对于类加载过程的其他阶段，加载阶段(准备地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段可以使用系统提供的类加载器(ClassLoader)来完成，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。   
加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式有虚拟机实现自行定义，虚拟机并未规定此区域的具体数据结构。然后在java堆中实例化一个java.lang.Class类的对象，这个对象作为程序访问方法区中的这些类型数据的外部接口。   
## 验证：（了解）
验证是链接阶段的第一步，这一步主要的目的是确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。
验证阶段主要包括四个检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。  
## 准备：（了解）
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的知识点，首先是这时候进行内存分配的仅包括类变量(static 修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为:
```
public static int value  = 12;
```
那么变量value在准备阶段过后的初始值为0而不是12，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器\<clinit>()方法之中，所以把value赋值为12的动作将在初始化阶段才会被执行。

上面所说的“通常情况”下初始值是零值，那相对于一些特殊的情况，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，建设上面类变量value定义为：
```
public static final int value = 123;
```
编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value设置为123。
## 解析：（了解）
解析阶段是虚拟机常量池内的符号引用替换为直接引用的过程。
符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。

直接引用：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。
* 类、接口的解析
* 字段解析
* 类方法解析
* 接口方法解析
5.初始化：（了解）

类的初始化阶段是类加载过程的最后一步，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器\<clinit>()方法的过程。在以下四种情况下初始化过程会被触发执行：
1.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。生成这4条指令的最常见的java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候，以及调用类的静态方法的时候。
2.使用java.lang.reflect包的方法对类进行反射调用的时候
3.当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化
4.jvm启动时，用户指定一个执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类
在上面准备阶段 
```
public static int value  = 12; 
```
 在准备阶段完成后 value的值为0，而在初始化阶调用了类构造器\<clinit>()方法，这个阶段完成后value的值为12。
* 类构造器\<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句快可以赋值，但是不能访问。
* 类构造器\<clinit>()方法与类的构造函数(实例构造函数\<init>()方法)不同，它不需要显式调用父类构造，虚拟机会保证在子类\<clinit>()方法执行之前，父类的\<clinit>()方法已经执行完毕。因此在虚拟机中的第一个执行的\<clinit>()方法的类肯定是java.lang.Object。
* 由于父类的\<clinit>()方法先执行，也就意味着父类中定义的静态语句快要优先于子类的变量赋值操作。
* \<clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句，也没有变量赋值的操作，那么编译器可以不为这个类生成\<clinit>()方法。
* 接口中不能使用静态语句块，但接口与类不太能够的是，执行接口的\<clinit>()方法不需要先执行父接口的\<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的\<clinit>()方法。
* 虚拟机会保证一个类的\<clinit>()方法在多线程环境中被正确加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程执行这个类的\<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行\<clinit>()方法完毕。如果一个类的\<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞。   
[toTop](#jump)

# 类加载器
## 类与类加载器
Java程序一般会使用到以下三种系统提供的类加载器：
1) 启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库到JVM内存中，如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。
2) 扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\lib\，该加载器可以被开发者直接使用。
3) 应用程序类加载器（Application ClassLoader）：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
## 双亲委派模型
![](/img/Parents_Delegation_Model.jpg)
双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。   
使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。
源代码如下
```
    protected synchronized Class loadClass(String name, boolean resolve)  
            throws ClassNotFoundException {  
        // 首先检查该name指定的class是否有被加载  
        Class c = findLoadedClass(name);  
        if (c == null) {  
            try {  
                if (parent != null) {  
                    // 如果parent不为null，则调用parent的loadClass进行加载  
                    c = parent.loadClass(name, false);  
                } else {  
                    // parent为null，则调用BootstrapClassLoader进行加载  
                    c = findBootstrapClass0(name);  
                }  
            } catch (ClassNotFoundException e) {  
                // 如果仍然无法加载成功，则调用自身的findClass进行加载  
                c = findClass(name);  
            }  
        }  
        if (resolve) {  
            resolveClass(c);  
        }  
        return c;  
    }  
```
[toTop](#jump)

# java内存区域
![](/img/java_memory.jpg)
![](/img/java_memory2.jpg)  
[toTop](#jump)

# 堆，栈，方法区存储内容
* 栈区: 
1) **每个线程包含一个栈区**，栈中只保存方法中（不包括对象的成员变量）的**基础数据类型和自定义对象的引用(不是对象**，对象都存放在堆区中
2) 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
3) 栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
* 堆区: 
1) 存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。
2) **jvm只有一个堆区(heap)被所有线程共享**，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的**对象实例和数组**都在堆中分配。
* 方法区: 又叫静态区，跟堆一样，被所有的线程共享。它用于存储**已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等**数据。   
[toTop](#jump)

# 垃圾回收
## 如何确定某个对象是“垃圾”
Java中采取了**可达性分析法**。该方法的基本思想是通过一系列的“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。  
**GC ROOT**包括：
1) 虚拟机栈（栈中的本地变量表）中引用的对象；
2) 方法区中类静态属性引用的对象；
3) 方法区中常量引用的对象；
4) 本地方法栈中JNI（即一般说的Native方法）引用的对象。
## 典型的垃圾收集算法
1) 标记-清除算法（Mark-Sweep)
首先标记出需要回收的对象，在标记完成后统一回收掉所有的被标记对象。  
缺点：效率问题和空间问题（标记清除后会产生大量的不连续内存碎片，内存碎片过多可能会导致程序需要分配较大对象时找不到足够大的连续内存空间而不得不提前触发另一次垃圾回收动作）
![](/img/mark_sweep.png)
2) 复制算法（Copying)
将内存划分为大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将还存活的对象复制到另一块内存上，然后把已使用过的内存空间一次清理掉。   
优点：每次只对其中一块进行GC,不用考虑内存碎片的问题，并且实现简单，运行高效   
缺点：内存缩小了一半
![](/img/copying.png)
注：现在的商业虚拟机都是用这种收集算法回收新生代。内存分为一块较大的Eden空间和两块较小的Survior空间，每次使用Eden和其中的一块Survior.当回收时，将Eden和Survior中还存活的对象一次性拷贝到另外一块Survior空间上，最后清理Eden和刚才用过的Survior空间。
3) 标记-整理算法（Mark-Compact
让所有存活对象都向一端移动，然后直接清理掉端边界以外的所有内存。
![](/img/mark_compact.png)
4) 分代收集算法（Generational Collection）
根据对象的存活周期的不同将内存划分为几块，一般就分为新生代和老年代，根据各个年代的特点采用不同的收集算法。新生代（少量存活）用复制算法，老年代（对象存活率高）“标记-清理”算法   
整个JVM内存总共划分为三代：年轻代、年老代、持久代
* 年轻代：所有新生成的对象首先都放在年轻代内存中。年轻代的目标就是尽可能快速的手机掉那些生命周期短的对象。年轻代内存分为一块较大的Eden空间和两块较小的Survior空间，每次使用Eden和其中的一块Survior.当回收时，将Eden和Survior中还存活的对象一次性拷贝到另外一块Survior空间上，最后清理Eden和刚才用过的Survior空间。
* 年老代：在年轻代经历了N次GC后，仍然存活的对象，就会被放在老年代中。因此可以认为老年代存放的都是一些生命周期较长的对象。
* 持久代：基本固定不变，用于存放静态文件，例如Java类和方法。持久代对GC没有显著的影响。持久代可以通过-XX:MaxPermSize=<N>进行设置。**(java8中永久代废弃，以metaspace代替。metaspace使用本地内存。)**    
[toTop](#jump)

# 常用JVM优化参数
```
-Xmx
　　指定java程序的最大堆内存, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存   

-Xms
　　指定最小堆内存, 通常设置成跟最大堆内存一样，减少GC

-Xmn
　　设置年轻代大小为512m。整个堆大小=年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。

-Xss
　　指定线程的最大栈空间, 此参数决定了java函数调用的深度, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)
设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程 大约需要占用多少内存，可能会有多少线程同时运行等。一般不易设置超过1M，要不然容易出现out of memory

-XX:PermSize
　　指定方法区(永久区)的初始值,默认是物理内存的1/64， 在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定

-XX:MaxPermSize
　　指定方法区的最大值, 默认是物理内存的1/4，在java8中由-XX:MaxMetaspaceSize指定元数据区的大小
```
[toTop](#jump)
